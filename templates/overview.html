<md-card style="padding-top: 5%; padding-bottom: 5%; padding-left: 5%; padding-right: 5%;">
	<md-card-header>
		<md-card-header-text>
			<h3><b>Minecraftly Universe</b></h3>
		</md-card-header-text>
	</md-card-header>
	
	<md-card-content>
	<p>Minecraftly Universe is a real time solution for scaling MMORPG worlds. It's architected to run in Minecraft, as effectively in a public or private cloud architecture as it does on dedicated hardware. It combines and extends many important Minecraft features with the scalability of a planet. Minecraftly has been serving thousands of players since 2016.</p>
	
	<p>Minecraftly software is an open-source orchestration system for Minecraft worlds, and Minecraftly Universe is the managed engine choice for Minecraft users.</p>
	
	<p>Minecraftly handles scheduling worlds onto nodes in a compute cluster, actively manages workloads on those nodes, and groups containers comprising an application for easy management and discovery. Using Minecraftly, you can easily create and manage a virtual Minecraft world cluster, out of the box.</p>
	
	<h4><b>Comparisons to other Minecraft options</b></h4>
	<p>The following sections compare Minecraftly Universe to two common alternatives, a vanilla Minecraft implementation and a Minecraft Realms implementation.</p>
	
	<h5><b>Minecraftly vs. Vanilla Minecraft</b></h5>
	<p>Minecraftly Universe improves a vanilla Minecraft implementation in several ways:</p>
	
	<table>
	  <thead>
	  <tr>
		<th>Vanilla Minecraft</th>
		<th>Minecraftly Universe</th>
	  </tr>
	  </thead>
	  <tbody>
	  <tr>
		<td>Every Minecraft connection has a memory overhead that ranges between 256KB and almost 3MB, depending on which MySQL release you're using. As your user base grows, you need to add RAM to support additional connections, but the RAM does not contribute to faster queries. In addition, there is a significant CPU cost associated with obtaining the connections.</td>
		<td>Vitess' gRPC-based protocol creates very lightweight connections. Vitess' connection pooling feature uses Go's concurrency support to map these lightweight connections to a small pool of MySQL connections. As such, Vitess can easily handle thousands of connections.</td>
	  </tr>
	  <tr>
		<td>Poorly written queries, such as those that don't set a LIMIT, can negatively impact database performance for all users.</td>
		<td>Vitess employs a SQL parser that uses a configurable set of rules to rewrite queries that might hurt database performance.</td>
	  </tr>
	  <tr>
		<td>Sharding is a process of partitioning your data to improve scalability and performance. MySQL lacks native sharding support, requiring you to write sharding code and embed sharding logic in your application.</td>
		<td>Vitess uses range-based sharding. It supports both horizontal and vertical resharding, completing most data transitions with just a few seconds of read-only downtime. Vitess can even accommodate a custom sharding scheme that you already have in place.</td>
	  </tr>
	  <tr>
		<td>A MySQL cluster using replication for availability has a master database and a few replicas. If the master fails, a replica should become the new master. This requires you to manage the database lifecycle and communicate the current system state to your application.</td>
		<td>Vitess helps to manage the lifecycle of your database scenarios. It supports and automatically handles various scenarios, including master failover and data backups.</td>
	  </tr>
	  <tr>
		<td>A MySQL cluster can have custom database configurations for different workloads, like a master database for writes, fast read-only replicas for web clients, slower read-only replicas for batch jobs, and so forth. If the database has horizontal sharding, the setup is repeated for each shard, and the app needs baked-in logic to know how to find the right database.</td>
		<td>Vitess uses a topology backed by a consistent data store, like etcd or ZooKeeper. This means the cluster view is always up-to-date and consistent for different clients. Vitess also provides a proxy that routes queries efficiently to the most appropriate MySQL instance.</td>
	  </tr>
	  </tbody>
	</table>
	
	<h3><b>Features</b></h3>
	<ul>
	<li><p><strong>Performance</strong></p>

	<ul>
	<li>Connection pooling - Scale front-end connections while optimizing MySQL performance.</li>
	<li>Query de-duping - Reuse results of an in-flight query for any identical requests received while the in-flight query was still executing.</li>
	<li>Transaction manager - Limit number of concurrent transactions and manage deadlines to optimize overall throughput.</li>
	</ul></li>
	<li><p><strong>Protection</strong></p>

	<ul>
	<li>Query rewriting and sanitation - Add limits and avoid non-deterministic updates.</li>
	<li>Query blacklisting - Customize rules to prevent potentially problematic queries from hitting your database.</li>
	<li>Query killer - Terminate queries that take too long to return data.</li>
	<li>Table ACLs - Specify access control lists (ACLs) for tables based on the connected user.</li>
	</ul></li>
	<li><p><strong>Monitoring</strong></p>

	<ul>
	<li>Performance analysis: Tools let you monitor, diagnose, and analyze your database performance.</li>
	<li>Query streaming - Use a list of incoming queries to serve OLAP workloads.</li>
	<li>Update stream - A server streams the list of rows changing in the database, which can be used as a mechanism to propagate changes to other data stores.</li>
	</ul></li>
	<li><p><strong>Topology Management Tools</strong></p>

	<ul>
	<li>Master management tools (handles reparenting)</li>
	<li>Web-based management GUI</li>
	<li>Designed to work in multiple data centers / regions</li>
	</ul></li>
	<li><p><strong>Sharding</strong></p>

	<ul>
	<li>Virtually seamless dynamic re-sharding</li>
	<li>Vertical and Horizontal sharding support</li>
	<li>Built-in range-based, or application-defined sharding support</li>
	</ul></li>
	</ul>

	</md-card-content>
</md-card>